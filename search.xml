<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Breath_First Search</title>
    <url>/2022/02/14/Breath-First-Search/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>深度优先遍历(Depth First Search, 简称 DFS) 与广度优先遍历(Breath First Search)是图论中两种非常重要的算法,生产上广泛用于拓扑排序,寻路(走迷宫),搜索引擎,爬虫等,也频繁出现在 leetcode,高频面试题中。</p>
<p>本文将会从以下几个方面来讲述广度优先遍历相信大家看了肯定会有收获。</p>
<h1 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h1><ul>
<li>广度优先遍历简介</li>
<li>搜索引擎中的应用</li>
</ul>
<h2 id="广度优先遍历简介"><a href="#广度优先遍历简介" class="headerlink" title="广度优先遍历简介"></a>广度优先遍历简介</h2><p>广度优先遍历</p>
<p>广度优先遍历,指的是从图的一个未遍历的节点出发,先遍历这个节点的相邻节点,再依次遍历每个相邻节点的相邻节点。</p>
<p>上文所述树的广度优先遍历动图如下,每个节点的值即为它们的遍历顺序。所以广度优先遍历也叫层序遍历,先遍历第一层(节点 1),再遍历第二层(节点 2,3,4),第三层(5,6,7,8),第四层(9,10)。<br><img src="https://img-blog.csdnimg.cn/40f0c6261137430984dd15823fceec7c.gif#pic_center" alt="在这里插入图片描述"></p>
<p>深度优先遍历用的是栈,而广度优先遍历要用队列来实现,我们以下图二叉树为例来看看如何用队列来实现广度优先遍历。</p>
<p><img src="https://img-blog.csdnimg.cn/988de54666f04ee785c26b31882b365e.png" alt="在这里插入图片描述"><br>动图如下:</p>
<p><img src="https://img-blog.csdnimg.cn/1a95d16c9e70495991bef1f00362ce01.gif#pic_center" alt="在这里插入图片描述"><br>相信看了以上动图,不难写出如下代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 使用队列实现 bfs </span><br><span class="line"> * @param root </span><br><span class="line"> */ </span><br><span class="line">private static void bfs(Node root) &#123; </span><br><span class="line">    if (root == null) &#123; </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line">    Queue&lt;Node&gt; stack = new LinkedList&lt;&gt;(); </span><br><span class="line">    stack.add(root); </span><br><span class="line"> </span><br><span class="line">    while (!stack.isEmpty()) &#123; </span><br><span class="line">        Node node = stack.poll(); </span><br><span class="line">        System.out.println(&quot;value = &quot; + node.value); </span><br><span class="line">        Node left = node.left; </span><br><span class="line">        if (left != null) &#123; </span><br><span class="line">            stack.add(left); </span><br><span class="line">        &#125; </span><br><span class="line">        Node right = node.right; </span><br><span class="line">        if (right != null) &#123; </span><br><span class="line">            stack.add(right); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="搜索引擎中的应用"><a href="#搜索引擎中的应用" class="headerlink" title="搜索引擎中的应用"></a>搜索引擎中的应用</h2><p>DFS,BFS 在搜索引擎中的应用我们几乎每天都在 Google, Baidu 这些搜索引擎,那大家知道这些搜索引擎是怎么工作的吗?简单来说有三步:</p>
<p>1、网页抓取</p>
<p>搜索引擎通过爬虫将网页爬取，获得页面 HTML 代码存入数据库中</p>
<p>2、预处理</p>
<p>索引程序对抓取来的页面数据进行文字提取,中文分词,(倒排)索引等处理,以备排名程序使用</p>
<p>3、排名</p>
<p>用户输入关键词后,排名程序调用索引数据库数据,计算相关性,然后按一定格式生成搜索结果页面。</p>
<p>我们重点看下第一步,网页抓取。</p>
<p>这一步的大致操作如下,给爬虫分配一组起始的网页,我们知道网页里其实也包含了很多超链接,爬虫爬取一个网页后,解析提取出这个网页里的所有超链接.再依次爬取出这些超链接,再提取网页超链接。。。如此不断重复就能不断根据超链接提取网页,最终构成了一张图,于是问题就转化为了如何遍历这张图,显然可以用深度优先或广度优先的方式来遍历。</p>
<p>如果是广度优先遍历,先依次爬取第一层的起始网页,再依次爬取每个网页里的超链接,如果是深度优先遍历,先爬取起始网页 1,再爬取此网页里的链接…,爬取完之后,再爬取起始网页 2…</p>
<p>实际上爬虫是深度优先与广度优先两种策略一起用的,比如在起始网页里,有些网页比较重要(权重较高),那就先对这个网页做深度优先遍历,遍历完之后再对其他(权重一样的)起始网页做广度优先遍历。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>DFS 和 BFS 是非常重要的两种算法,大家一定要掌握,本文为了方便讲解,只对树做了DFS,BFS,大家可以试试如果用图的话该怎么写代码,原理其实也是一样,只不过图和树两者的表示形式不同而已,DFS 一般是解决连通性问题,而 BFS 一般是解决最短路径问题。<br>广度优先遍历是不是明显要比深度优先遍历简单得多,相信大家一定对广度优先遍历的理解更深了.若有不对的地方.欢迎指出.谢谢大家.</p>
]]></content>
      <categories>
        <category>广度遍历算法 图</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇文章</title>
    <url>/2022/02/13/FirstTest/</url>
    <content><![CDATA[<h1 id="主动进步的一天"><a href="#主动进步的一天" class="headerlink" title="主动进步的一天"></a>主动进步的一天</h1><p>在Yearito的博客的指导下,终于搭建好了Hexo博客.<br>2022&#x2F;2&#x2F;13从这一天开始进步,从这一天开始不再害怕困难.</p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>出生日</tag>
      </tags>
  </entry>
  <entry>
    <title>Depth_First Search</title>
    <url>/2022/02/14/Depth-First-Search/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>深度优先遍历(Depth First Search, 简称 DFS) 与广度优先遍历(Breath First Search)是图论中两种非常重要的算法,生产上广泛用于拓扑排序,寻路(走迷宫),搜索引擎,爬虫等,也频繁出现在 leetcode,高频面试题中。</p>
<p>本文将会从以下几个方面来讲述深度优先遍历相信大家看了肯定会有收获。</p>
<h1 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h1><ul>
<li>深度优先遍历简介</li>
<li>习题演练</li>
<li>DFS在搜索引擎中的应用</li>
</ul>
<h2 id="深度优先遍历简介"><a href="#深度优先遍历简介" class="headerlink" title="深度优先遍历简介"></a>深度优先遍历简介</h2><p>主要思路是从图中一个未访问的顶点 V 开始,沿着一条路一直走到底,然后从这条路尽头的节点回退到上一个节点,再从另一条路开始走到底…,不断递归重复此过程,直到所有的顶点都遍历完成,它的特点是不撞南墙不回头,先走完一条路,再换一条路继续走。</p>
<p>树是图的一种特例(连通无环的图就是树)，接下来我们来看看树用深度优先遍历该怎么遍历。</p>
<p><img src="https://img-blog.csdnimg.cn/3167ab6c06c247949ab70a5b51626dc9.png" alt="在这里插入图片描述"></p>
<p>1、我们从根节点 1 开始遍历,它相邻的节点有 2,3,4,先遍历节点 2,再遍历 2 的子节点 5,然后再遍历 5 的子节点 9。</p>
<p><img src="https://img-blog.csdnimg.cn/9a9de04677b64f38a581db686d2132e7.png" alt="在这里插入图片描述"></p>
<p>2、上图中一条路已经走到底了(9是叶子节点，再无可遍历的节点),此时就从 9 回退到上一个节点 5,看下节点 5 是否还有除 9 以外的节点,没有继续回退到 2,2 也没有除 5 以外的节点,回退到 1.1 有除 2 以外的节点 3,所以从节点 3 开始进行深度优先遍历,如下:<br><img src="https://img-blog.csdnimg.cn/2bdd1434db8d4715b6c32d4b6121a31a.png" alt="在这里插入图片描述"></p>
<p>3、同理从 10 开始往上回溯到 6, 6 没有除 10 以外的子节点,再往上回溯,发现 3 有除 6 以外的子点 7,所以此时会遍历 7。</p>
<p><img src="https://img-blog.csdnimg.cn/1a1b0aa919d44448b68a1cea569c0976.png" alt="在这里插入图片描述"></p>
<p>4、从 7 往上回溯到 3, 1,发现 1 还有节点 4 未遍历,所以此时沿着 4, 8 进行遍历,这样就遍历完成了。</p>
<p>完整的节点的遍历顺序如下(节点上的的蓝色数字代表):</p>
<p><img src="https://img-blog.csdnimg.cn/a30bfea9e90c4749b0bfe9c9f595495e.png" alt="在这里插入图片描述"></p>
<p>相信大家看到以上的遍历不难发现这就是树的前序遍历,实际上不管是前序遍历,还是中序遍历,亦或是后序遍历,都属于深度优先遍历。</p>
<p>那么深度优先遍历该怎么实现呢?有递归和非递归两种表现形式.接下来我们以二叉树为例来看下如何分别用递归和非递归来实现深度优先遍历。</p>
<h2 id="1、递归实现"><a href="#1、递归实现" class="headerlink" title="1、递归实现"></a>1、递归实现</h2><p>递归实现比较简单,由于是前序遍历,所以我们依次遍历当前节点,左节点,右节点即可.对于左右节点来说,依次遍历它们的左右节点即可,依此不断递归下去.直到叶节点(递归终止条件),代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123; </span><br><span class="line">    private static class Node &#123; </span><br><span class="line">        /** </span><br><span class="line">         * 节点值 </span><br><span class="line">         */ </span><br><span class="line">        public int value; </span><br><span class="line">        /** </span><br><span class="line">         * 左节点 </span><br><span class="line">         */ </span><br><span class="line">        public Node left; </span><br><span class="line">        /** </span><br><span class="line">         * 右节点 </span><br><span class="line">         */ </span><br><span class="line">        public Node right; </span><br><span class="line"> </span><br><span class="line">        public Node(int value, Node left, Node right) &#123; </span><br><span class="line">            this.value = value; </span><br><span class="line">            this.left = left; </span><br><span class="line">            this.right = right; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    public static void dfs(Node treeNode) &#123; </span><br><span class="line">        if (treeNode == null) &#123; </span><br><span class="line">            return; </span><br><span class="line">        &#125; </span><br><span class="line">        // 遍历节点 </span><br><span class="line">        process(treeNode) </span><br><span class="line">        // 遍历左节点 </span><br><span class="line">        dfs(treeNode.left); </span><br><span class="line">        // 遍历右节点 </span><br><span class="line">        dfs(treeNode.right); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>递归的表达性很好,也很容易理解,不过如果层级过深,很容易导致栈溢出。所以我们重点看下非递归实现。</p>
<h2 id="2、非递归实现"><a href="#2、非递归实现" class="headerlink" title="2、非递归实现"></a>2、非递归实现</h2><p>仔细观察深度优先遍历的特点;对二叉树来说,由于是先序遍历(先遍历当前节点,再遍历左节点,再遍历右节点),所以我们有如下思路:</p>
<p>对于每个节点来说,先遍历当前节点,然后把右节点压栈,再压左节点(这样弹栈的时候会先拿到左节点遍历,符合深度优先遍历要求)。</p>
<p>弹栈,拿到栈顶的节点,如果节点不为空,重复步骤 1. 如果为空,结束遍历。</p>
<p>我们以以下二叉树为例来看下如何用栈来实现 DFS。<br><img src="https://img-blog.csdnimg.cn/a70e2431b14640e1b8fbcd1cd5ff394a.png" alt="在这里插入图片描述"><br>整体动图如下：<br><img src="https://img-blog.csdnimg.cn/4e0021faa8324ba896d69be4a725a317.gif#pic_center" alt="在这里插入图片描述"></p>
<p>整体思路还是比较清晰的,使用栈来将要遍历的节点压栈,然后出栈后检查此节点是否还有未遍历的节点,有的话压栈，没有的话不断回溯(出栈),有了思路,不难写出如下用栈实现的二叉树的深度优先遍历代码.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 使用栈来实现 dfs </span><br><span class="line"> * @param root </span><br><span class="line"> */ </span><br><span class="line">public static void dfsWithStack(Node root) &#123; </span><br><span class="line">    if (root == null) &#123; </span><br><span class="line">        return; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); </span><br><span class="line">    // 先把根节点压栈 </span><br><span class="line">    stack.push(root); </span><br><span class="line">    while (!stack.isEmpty()) &#123; </span><br><span class="line">        Node treeNode = stack.pop(); </span><br><span class="line">        // 遍历节点 </span><br><span class="line">        process(treeNode) </span><br><span class="line"> </span><br><span class="line">        // 先压右节点 </span><br><span class="line">        if (treeNode.right != null) &#123; </span><br><span class="line">            stack.push(treeNode.right); </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        // 再压左节点 </span><br><span class="line">        if (treeNode.left != null) &#123; </span><br><span class="line">            stack.push(treeNode.left); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到用栈实现深度优先遍历其实代码也不复杂,而且也不用担心递归那样层级过深导致的栈溢出问题。</p>
<h2 id="搜索引擎中的应用"><a href="#搜索引擎中的应用" class="headerlink" title="搜索引擎中的应用"></a>搜索引擎中的应用</h2><p>DFS,BFS 在搜索引擎中的应用我们几乎每天都在 Google, Baidu 这些搜索引擎,那大家知道这些搜索引擎是怎么工作的吗?简单来说有三步:</p>
<p>1、网页抓取</p>
<p>搜索引擎通过爬虫将网页爬取，获得页面 HTML 代码存入数据库中</p>
<p>2、预处理</p>
<p>索引程序对抓取来的页面数据进行文字提取,中文分词,(倒排)索引等处理,以备排名程序使用</p>
<p>3、排名</p>
<p>用户输入关键词后,排名程序调用索引数据库数据,计算相关性,然后按一定格式生成搜索结果页面。</p>
<p>我们重点看下第一步,网页抓取。</p>
<p>这一步的大致操作如下,给爬虫分配一组起始的网页,我们知道网页里其实也包含了很多超链接,爬虫爬取一个网页后,解析提取出这个网页里的所有超链接.再依次爬取出这些超链接,再提取网页超链接。。。如此不断重复就能不断根据超链接提取网页,最终构成了一张图,于是问题就转化为了如何遍历这张图,显然可以用深度优先或广度优先的方式来遍历。</p>
<p>如果是广度优先遍历,先依次爬取第一层的起始网页,再依次爬取每个网页里的超链接,如果是深度优先遍历,先爬取起始网页 1,再爬取此网页里的链接…,爬取完之后,再爬取起始网页 2…</p>
<p>实际上爬虫是深度优先与广度优先两种策略一起用的,比如在起始网页里,有些网页比较重要(权重较高),那就先对这个网页做深度优先遍历,遍历完之后再对其他(权重一样的)起始网页做广度优先遍历。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>DFS 和 BFS 是非常重要的两种算法,大家一定要掌握,本文为了方便讲解,只对树做了DFS,BFS,大家可以试试如果用图的话该怎么写代码,原理其实也是一样,只不过图和树两者的表示形式不同而已,DFS 一般是解决连通性问题,而 BFS 一般是解决最短路径问题。<br>这就是我理解的深度优先遍历算法啦!如果有不太对的地方,欢迎指出,谢谢。</p>
]]></content>
      <categories>
        <category>深度遍历算法 图</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><center>
  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=329 height=86 src="//music.163.com/outchain/player?type=2&id=34613621&auto=0&height=66"></iframe>
</center>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>html</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
